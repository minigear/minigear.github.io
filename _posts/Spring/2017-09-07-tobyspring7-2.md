---
layout: post
title:  "Toby 스프링3 7장-2"
date:   2017-09-07 13:36:00 +0900
categories: [Spring]
permalink: /spring/:year/:month/:day/:title/
tags: [스프링, spring, annotation]
comments: true
---

### 7.6 스프링 3.1의 DI
객체지향 코드의 장점 : 유연성과 확장성
#### 자바 언어의 변화와 스프링   
##### - 애노테이션의 메타정보 활용
자바 코드의 메타정보를 이용한 프로그래밍 방식으로 발전해 왔다.   
애노테이션은 자바코드가 실행되는데 직접 참여하지 못 한다. 복잡한 리플랙션API를 이용해 애노테이션의 메타정보를 조회하고, 애노테이션 내에 설정된 값을 가져와 참고하는 방법이 전부이다.   
그렇다면 왜 애노테이션의 활용성이 늘었을까?   
스프링은 핵심로직을 담은 자바코드와 IOC프레임워크, 프레임워크가 참조하는 메타정보로 구성되어 있다.  
IOC프레임워크는 메타정보를 통해 객체의 관계를 파악하고 핵심로직이 담긴 객체를 생성한다.
>DAOFactory -> xml -> 애노테이션 순으로 발전

애노테이션은 xml이나 여타 외부파일과 달리 자바코드의 일부로 사용된다.   
**장점**   
a. xml은 애노테이션 하나를 자바코드에 넣는 것에 비해 작성한 정보가 많다.   
b. 텍스트 정보이기에 오타가 발생할 수 있다.   
c. 리펙토링이 쉽다.  
**단점**   
xml은 어느 환경에서나 손쉽게 편집이 가능하고 내용이 변경되어도 다시 빌드할 필요가 없다. 하지만 애노테이션은 재컴파일을 해줘야한다.   

##### - 정책과 관례를 이용한 프로그래밍   
애노테이션과 같은 메타정보를 활용하는 프로그래밍 방식은 코드를 이용해 명시적으로 동작 내용을 기술하는 대신 코드 없이 미리 약속한 규칙 또는 관례를 따라서 프로그램이 동작하도록 만드는 프로그래밍 스타일을 적극 포용하여 만들어 왔다.  
**장점** : 작성해야할 내용이 줄어든다.   
**단점** : 미리 정의된 규칙과 관례를 기억해야 하고, 메타정보를 보고 프로그램이 어떻게 동작할지 이해해야한다. 높은 학습비용이 필요하고 잘못 이해할 시에는 찾기 힘든 버그를 만들어낼 수있다.   

현재는 자바 9과 스프링5에서는 위의 문제점을 개선한다고 한다.(링크 참조)   

[토비님 발표 자바9과 스프링 5](https://minigear.github.io/etc/2017/08/30/oracle_code/)

-----

#### 7.6.1 자바코드를 이용한 빈 설정
기존의 메타정보를 담은 xml로 관리하였으나 이를 java코드로 변환하는 실습
##### 테스트 컨텍스트의 변경
**@ContextConfiguration**: 스프링 테스트가 테스트용 DI 정보를 어디서 가져와야 하는지 지정할 때 사용하는 애노테이션   
@ContextConfiguration이 XML 대신 DI 정보를 담고 있는 클래스를 이용하도록 변경   
1. DI정보를 담은 클래스는 평범한 자바 클래스에 **@Configruation** 애노테이션을 달아주면 된다.
2. 자바 클래스로 만들어진 DI 설정 정보에 xml의 설정 정보를 가져오게 할수 있다.  
  **@ImportResource** 를 사용

##### \<context: annotation-config/> 제거
  \<context: annotation-config/>는 \@PostConstruct를 붙인 메소드가 빈이 초기화된 후 자동 실행되도록 하는 용도로 사용되었다.

##### \<bean>의 전환
\<bean>은 @Bean이 붙은 public 메소드로 만들어주면 된다.   
메소드 이름은 \<bean>의 id값으로 한다.  
메소드의 리턴타입은 빈이 주입 받아서 사용하는 빈에서 어떤 타입으로 사용 되는지 확인할 필요가 있다.
생성할 빈 오브젝트의 클래스는 \<bean>의 class에 나온것을 그대로 사용하면 된다.   
프로퍼티가 있는 경우엔 일단 로컬변수로 받아둬야 한다.   
@bean메소드 내부에서는 빈의 구현 클래스에 맞는 프로퍼티값 주입이 필요하다. 프로퍼티는 구현 클래스에 의존적인 경우가 대부분이다. 따라서 빈 내부에서 new키워드를 사용해 빈 인스턴스를 만드는 경우 구현 클래스 타입으로 변수를 만들어야 한다.   

@Configruation 자바 파일에서 생성한 빈과 xml로 생성한 빈은 서로 참조가 가능하다.   

**@Autowired** 가 붙은 필드의 티입과 같은 빈이 있으면 해당 빈을 필드에 자동으로 넣어준다.   

**@Resource** 는 @Autowired와 유사하지만 @Autowired는 타입기준으로 찾고 @Resource는 필드이름 기준으로 빈을 검색한다.   

##### 전용태그 전환
\<jdbc: embedded-database> 전용 태그는 type에 지정한 내장형 DB를 생성하고 \<jdbc:script>로 지정한 스크립트로 초기화한 뒤에 DataSource 타입 DB의 커낵션 오브젝트를 빈으로 등록한다.  
자바 코드에서는 **EmbeddedDatabaseBuilder** 를 이용해 위의 작업을 진행한다.   

\<tx: annotation-driven/> 의 제거   
AOP를 위해서 어드바이스와 포인트컷이 필요하고, 애노테이션 정보에서 트랜잭션 속성을 가져와 어드바이스에서 사용하게 해주는 역할을 한다.   
스프링 3.1 부터는 **\@EnableTransactionManagement** 를 지원한다.   

스프링 3.1 부터는 xml에서 자주 사용되는 전용 태그를 **@Enable** 로 시작하는 애노테이션으로 대체할 수 있도록 다양한 애노테이션을 제공한다.   

#### 7.6.2 빈스캐닝과 자동와이어링
##### @Autowired를 이용한 자동와이어링

빈의 프로퍼티에 다른 빈을 넣어서 런타임시 관계를 맺어 주려면 \<bean>의 \<property>를 사용해 빈을 정의하거나 자바코드로 직접 수정자 메소드를 호출해 줘야 했다.  

**@Autowired** 는 자동와이어링기법을 이용해서 조건에 맞는 빈을 찾아 자동으로 수정자 메소드나 필드에 넣어 준다. 컨테이너가 자동으로 주입할 빈을 결정하기 어려운 경우도 있다. 이럴 경우에는 직접 프로퍼티에 주입할 대상을 지정하는 방법을 병행하면 된다.   
필드의 접근 제한자가 private로 선언되어 문제가 되지 않는다 스프링은 리플랙션 API를 이용하여 접근 제한자를 우회하여 값을 넘겨 준다.   

스프링과 무관하게 직접 오브젝트를 생성하고 다른 오브젝트에 주입해서 테스트 하는 순수 단위 테스트의 경우 수정자 메소드가 필요하다.  

###### @Autowired와 같은 자동와이어링을 적절하게 사용의 장단점   
**장점**: DI관련 코드를 대폭 줄일 수 있어서 관리가 편리하다.   
**단점**: 설정정보를 보고 다른 빈과 의존관계가 어떻게 맺어져 있는지 한눈에 파악하기 힘들다

###### @Component를 이용한 자동 빈 등록
- @Component가 붙은 클래스는 빈스캐너를 통해 자동으로 빈으로 등록된다.
- @Component 애노테이션이 달린 클래스를 자동으로 찾아서 빈을 등록해주게 하려면 빈 스캐닝 기능을 사용하겠다는 애노테이션 정의가 필요하다. 빈 자동등록이 컨테이너가 디폴트로 제공하는 기능이 아니기 때문이다. 프로젝트내의 모든 클래스패스를 뒤져서 @Component 애노테이션이 달린 클래스를 찾는 것은 부담이 많이 가는 작업이다. 그래서 특정 패키지만 찾도록 기준이 되는 패키지를 지정할 필요가 있다. 이때 사용되는 애노테이션이 **@ComponentScan** 이다.   
- @Component가 붙은 클래스가 발견되면 새로운 빈을 자동으로 추가한다. 빈의 클래스는 @Component가 붙은 클래스이고, 빈의 아이디는 따로 지정하지 않는다면 클래스 이름의 첫글자를 소문자로 바꾸어 사용한다.
- @Component에 의해 자동으로 빈을 등록하면 @Autowired에서 사용할 때는 별 문제가 안되지만 @Resource로 사용할 때는 아이디를 기준으로 찾음으로 문제가 발생할 수 있다. 만약 @Component가 붙은 클래스의 이름 대신에 다른 이름을 빈을 아이디로 사용하고 싶다면 **@Component("이름")** 을 넣어준다.

---

애노테이션은 @interface 키워드를 이용해 정의한다.
```java
public @interface Component {
......
}

```
**메타 애노테이션**: 애노테이션의 정의에 부여된 애노테이션   
여러개의 애노태이션에 공통의 속성을 부여할 때 메타 애노테이션을 이용한다.   

###### @Repository : DAO 빈을 자동등록할 때 사용
###### @Service : 비즈니스 로직을 담고 있는 서비스 계층의 빈을 구분하기 위해 사용
